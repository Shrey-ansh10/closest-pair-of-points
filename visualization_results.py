#!/usr/bin/env python3
import sys
import os
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

def visualize_results(csv_file):
    """
    Visualize the results from the CSV file generated by the C++ program.
    """
    # Check if file exists
    if not os.path.isfile(csv_file):
        print(f"Error: File {csv_file} does not exist")
        return False
    
    # Read the CSV file
    try:
        df = pd.read_csv(csv_file)
        print("Data loaded successfully:")
        print(df.head())
    except Exception as e:
        print(f"Error reading CSV file: {e}")
        return False
    
    # Handle missing values (convert empty strings to NaN)
    df = df.replace('', np.nan)
    df['ALG1_Time_ms'] = pd.to_numeric(df['ALG1_Time_ms'], errors='coerce')
    
    # Estimate missing brute force times based on O(n²) complexity
    # We'll use the largest available brute force time for estimation
    if df['ALG1_Time_ms'].isna().any():
        print("Missing values detected for brute force algorithm. Estimating...")
        
        # Get the last valid brute force measurement
        last_valid_idx = df['ALG1_Time_ms'].last_valid_index()
        if last_valid_idx is not None:
            last_valid_n = df.loc[last_valid_idx, 'n']
            last_valid_time = df.loc[last_valid_idx, 'ALG1_Time_ms']
            
            # Estimate missing values based on O(n²) complexity
            for idx in df.index[df['ALG1_Time_ms'].isna()]:
                current_n = df.loc[idx, 'n']
                estimated_time = last_valid_time * (current_n / last_valid_n) ** 2
                df.loc[idx, 'ALG1_Time_ms_estimated'] = estimated_time
                print(f"  Estimated time for n={current_n}: {estimated_time:.2f} ms")
    
    
    # ------------------- NEW REQUIRED GRAPHS --------------------
    
    # Calculate constants and create tables
    # Create theoretical complexity values
    df['ALG1_TheoreticalRT'] = df['n']**2  # O(n²)
    df['ALG2_TheoreticalRT'] = df['n'] * np.log2(df['n'])  # O(n log n) with log base 2
    
    # Calculate constants (c1 and c2)
    valid_data = df.dropna(subset=['ALG1_Time_ms'])
    if not valid_data.empty:
        # Calculate c1 for ALG1
        ratios_c1 = valid_data['ALG1_Time_ms'] / valid_data['ALG1_TheoreticalRT']
        c1 = np.max(ratios_c1)
        print(f"Constant c1 for ALG1: {c1:.10f}")
        
        # Use c1 to calculate predicted runtime for ALG1
        df['ALG1_PredictedRT'] = c1 * df['ALG1_TheoreticalRT']
    
    # Calculate c2 for ALG2
    ratios_c2 = df['ALG2_Time_ms'] / df['ALG2_TheoreticalRT']
    c2 = np.max(ratios_c2)
    print(f"Constant c2 for ALG2: {c2:.10f}")
    
    # Use c2 to calculate predicted runtime for ALG2
    df['ALG2_PredictedRT'] = c2 * df['ALG2_TheoreticalRT']
    
    # Print tables for the report
    print("\nTable for ALG1 (Brute Force):")
    print("n\tTheoreticalRT\tEmpiricalRT\tRatio\t\tPredictedRT")
    for idx, row in df.iterrows():
        if not np.isnan(row['ALG1_Time_ms']):
            ratio = row['ALG1_Time_ms'] / row['ALG1_TheoreticalRT']
            print(f"{int(row['n'])}\t{row['ALG1_TheoreticalRT']:.1f}\t\t{row['ALG1_Time_ms']:.2f}\t\t{ratio:.10f}\t{row['ALG1_PredictedRT']:.2f}")
    
    print("\nTable for ALG2 (Divide and Conquer):")
    print("n\tTheoreticalRT\tEmpiricalRT\tRatio\t\tPredictedRT")
    for idx, row in df.iterrows():
        ratio = row['ALG2_Time_ms'] / row['ALG2_TheoreticalRT']
        print(f"{int(row['n'])}\t{row['ALG2_TheoreticalRT']:.1f}\t\t{row['ALG2_Time_ms']:.2f}\t\t{ratio:.10f}\t{row['ALG2_PredictedRT']:.2f}")
    
    # ------------------- GRAPH 1: Empirical Running Time Comparison --------------------
    plt.figure(figsize=(10, 6))
    plt.plot(df['n'], df['ALG1_Time_ms'], 'o-', markersize=8, label='ALG1 (Brute Force)')
    plt.plot(df['n'], df['ALG2_Time_ms'], 's-', markersize=8, label='ALG2 (Divide & Conquer)')
    
    plt.xlabel('Number of Points (n)', fontsize=12)
    plt.ylabel('Running Time (ms)', fontsize=12)
    plt.title('1. Empirical Running Time Comparison', fontsize=14)
    plt.legend(fontsize=12)
    plt.grid(True)
    plt.xticks(df['n'])  # Use actual n values for x-ticks
    
    # Add data point markers with values
    for i, row in df.iterrows():
        if not np.isnan(row['ALG1_Time_ms']):
            plt.annotate(f"{row['ALG1_Time_ms']:.1f}", 
                        xy=(row['n'], row['ALG1_Time_ms']), 
                        xytext=(0, 10),
                        textcoords='offset points',
                        ha='center', fontsize=8)
            
        plt.annotate(f"{row['ALG2_Time_ms']:.1f}", 
                    xy=(row['n'], row['ALG2_Time_ms']), 
                    xytext=(0, -15),
                    textcoords='offset points',
                    ha='center', fontsize=8)
    
    plt.tight_layout()
    plt.savefig('1_empirical_comparison.png')
    
    # ------------------- GRAPH 2: ALG1 Empirical vs Predicted --------------------
    plt.figure(figsize=(10, 6))
    plt.plot(df['n'], df['ALG1_Time_ms'], 'o-', markersize=8, label='ALG1: Empirical')
    plt.plot(df['n'], df['ALG1_PredictedRT'], 'D--', markersize=6, label='ALG1: Predicted')
    
    plt.xlabel('Number of Points (n)', fontsize=12)
    plt.ylabel('Running Time (ms)', fontsize=12)
    plt.title('2. Brute-Force Algorithm (ALG1): Empirical vs. Predicted Running Time', fontsize=14)
    plt.legend(fontsize=12)
    plt.grid(True)
    plt.xticks(df['n'])  # Use actual n values for x-ticks
    plt.tight_layout()
    plt.savefig('2_alg1_empirical_vs_predicted.png')
    
    # ------------------- GRAPH 3: ALG2 Empirical vs Predicted --------------------
    plt.figure(figsize=(10, 6))
    plt.plot(df['n'], df['ALG2_Time_ms'], 's-', markersize=8, label='ALG2: Empirical')
    plt.plot(df['n'], df['ALG2_PredictedRT'], 'D--', markersize=6, label='ALG2: Predicted')
    
    plt.xlabel('Number of Points (n)', fontsize=12)
    plt.ylabel('Running Time (ms)', fontsize=12)
    plt.title('3. Divide-and-Conquer Algorithm (ALG2): Empirical vs. Predicted Running Time', fontsize=14)
    plt.legend(fontsize=12)
    plt.grid(True)
    plt.xticks(df['n'])  # Use actual n values for x-ticks
    plt.tight_layout()
    plt.savefig('3_alg2_empirical_vs_predicted.png')
    
    
    # Export the table to CSV for convenience
    table_df = df[['n', 'ALG1_TheoreticalRT', 'ALG1_Time_ms', 'ALG1_PredictedRT',
                  'ALG2_TheoreticalRT', 'ALG2_Time_ms', 'ALG2_PredictedRT']]
    table_df.to_csv('analysis_table.csv', index=False)
    print("\nAnalysis table has been saved to analysis_table.csv")
    
    # Show all plots
    plt.show()
    
    return True


# following code will check if the script is being run directly or imported as a module - more explaination at the end
if __name__ == "__main__":
    # Default CSV file location
    csv_file = "build/results.csv"
    
    # If a CSV file is provided as argument, use that instead
    if len(sys.argv) > 1:
        csv_file = sys.argv[1]
    
    visualize_results(csv_file) 

'''In Python, __name__ is a special built-in variable. When a Python file is executed, the Python interpreter sets this variable differently depending on how the file is being used:
    1. When you run a file directly (like python your_script.py), Python sets __name__ = "__main__" for that file.
    2. When a file is imported into another file (like import your_script), Python sets __name__ to the actual name of the module (e.g., __name__ = "your_script").
    
    -> This pattern creates two different behaviors for our code:
        - If someone runs this file directly, the code inside this if block will execute.
        - And If someone imports this file as a module in another script, this code will not execute.
    This is useful because sometimes you want to write code that can both:
    1. Be run as a standalone program
    2. Have its functions imported and used by other programs    
'''